
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>QEMU TCG Plugins &#8212; QEMU  documentation</title>
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Bitwise operations" href="bitops.html" />
    <link rel="prev" title="Introduction" href="multi-thread-tcg.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="qemu-tcg-plugins">
<h1>QEMU TCG Plugins<a class="headerlink" href="#qemu-tcg-plugins" title="Permalink to this headline">¶</a></h1>
<p>QEMU TCG plugins provide a way for users to run experiments taking
advantage of the total system control emulation can have over a guest.
It provides a mechanism for plugins to subscribe to events during
translation and execution and optionally callback into the plugin
during these events. TCG plugins are unable to change the system state
only monitor it passively. However they can do this down to an
individual instruction granularity including potentially subscribing
to all load and store operations.</p>
<div class="section" id="api-stability">
<h2>API Stability<a class="headerlink" href="#api-stability" title="Permalink to this headline">¶</a></h2>
<p>This is a new feature for QEMU and it does allow people to develop
out-of-tree plugins that can be dynamically linked into a running QEMU
process. However the project reserves the right to change or break the
API should it need to do so. The best way to avoid this is to submit
your plugin upstream so they can be updated if/when the API changes.</p>
<div class="section" id="api-versioning">
<h3>API versioning<a class="headerlink" href="#api-versioning" title="Permalink to this headline">¶</a></h3>
<p>All plugins need to declare a symbol which exports the plugin API
version they were built against. This can be done simply by:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">QEMU_PLUGIN_EXPORT</span> <span class="nb">int</span> <span class="n">qemu_plugin_version</span> <span class="o">=</span> <span class="n">QEMU_PLUGIN_VERSION</span><span class="p">;</span>
</pre></div>
</div>
<p>The core code will refuse to load a plugin that doesn’t export a
<cite>qemu_plugin_version</cite> symbol or if plugin version is outside of QEMU’s
supported range of API versions.</p>
<p>Additionally the <cite>qemu_info_t</cite> structure which is passed to the
<cite>qemu_plugin_install</cite> method of a plugin will detail the minimum and
current API versions supported by QEMU. The API version will be
incremented if new APIs are added. The minimum API version will be
incremented if existing APIs are changed or removed.</p>
</div>
<div class="section" id="exposure-of-qemu-internals">
<h3>Exposure of QEMU internals<a class="headerlink" href="#exposure-of-qemu-internals" title="Permalink to this headline">¶</a></h3>
<p>The plugin architecture actively avoids leaking implementation details
about how QEMU’s translation works to the plugins. While there are
conceptions such as translation time and translation blocks the
details are opaque to plugins. The plugin is able to query select
details of instructions and system configuration only through the
exported <em>qemu_plugin</em> functions.</p>
</div>
<div class="section" id="query-handle-lifetime">
<h3>Query Handle Lifetime<a class="headerlink" href="#query-handle-lifetime" title="Permalink to this headline">¶</a></h3>
<p>Each callback provides an opaque anonymous information handle which
can usually be further queried to find out information about a
translation, instruction or operation. The handles themselves are only
valid during the lifetime of the callback so it is important that any
information that is needed is extracted during the callback and saved
by the plugin.</p>
</div>
</div>
<div class="section" id="api">
<h2>API<a class="headerlink" href="#api" title="Permalink to this headline">¶</a></h2>
<dl class="c type">
<dt id="c.qemu_plugin_id_t">
<em class="property">type </em><code class="sig-name descname">qemu_plugin_id_t</code><a class="headerlink" href="#c.qemu_plugin_id_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Unique plugin ID</p>
</dd></dl>

<dl class="c struct">
<dt id="c.qemu_info_t">
<em class="property">struct </em><code class="sig-name descname">qemu_info_t</code><a class="headerlink" href="#c.qemu_info_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>system information for plugins</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">struct</span> <span class="n">qemu_info_t</span> <span class="p">{</span>
  <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">target_name</span><span class="p">;</span>
  <span class="n">struct</span> <span class="p">{</span>
    <span class="nb">int</span> <span class="nb">min</span><span class="p">;</span>
    <span class="nb">int</span> <span class="n">cur</span><span class="p">;</span>
  <span class="p">}</span> <span class="n">version</span><span class="p">;</span>
  <span class="nb">bool</span> <span class="n">system_emulation</span><span class="p">;</span>
  <span class="n">union</span> <span class="p">{</span>
    <span class="n">struct</span> <span class="p">{</span>
      <span class="nb">int</span> <span class="n">smp_vcpus</span><span class="p">;</span>
      <span class="nb">int</span> <span class="n">max_vcpus</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">system</span><span class="p">;</span>
  <span class="p">};</span>
<span class="p">};</span>
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">target_name</span></code></dt><dd><p>string describing architecture</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">version</span></code></dt><dd><p>minimum and current plugin API level</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">system_emulation</span></code></dt><dd><p>is this a full system emulation?</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">system</span></code></dt><dd><p>information relevant to system emulation</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure provides for some limited information about the
system to allow the plugin to make decisions on how to proceed. For
example it might only be suitable for running on some guest
architectures or when under full system emulation.</p>
<dl class="c function">
<dt id="c.qemu_plugin_install">
int <code class="sig-name descname">qemu_plugin_install</code><span class="sig-paren">(</span><a class="reference internal" href="#c.qemu_plugin_id_t" title="qemu_plugin_id_t">qemu_plugin_id_t</a> <em>id</em>, <em class="property">const</em> <a class="reference internal" href="#c.qemu_info_t" title="qemu_info_t">qemu_info_t</a> *<em>info</em>, int <em>argc</em>, char **<em>argv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.qemu_plugin_install" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Install a plugin</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">qemu_plugin_id_t</span> <span class="pre">id</span></code></dt><dd><p>this plugin’s opaque ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">qemu_info_t</span> <span class="pre">*info</span></code></dt><dd><p>a block describing some details about the guest</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">argc</span></code></dt><dd><p>number of arguments</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">**argv</span></code></dt><dd><p>array of arguments (<strong>argc</strong> elements)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>All plugins must export this symbol which is called when the plugin
is first loaded. Calling qemu_plugin_uninstall() from this function
is a bug.</p>
<p><strong>Note</strong></p>
<p><strong>info</strong> is only live during the call. Copy any information we
want to keep. <strong>argv</strong> remains valid throughout the lifetime of the
loaded plugin.</p>
<p><strong>Return</strong></p>
<p>0 on successful loading, !0 for an error.</p>
<dl class="c macro">
<dt id="c.qemu_plugin_simple_cb_t">
<code class="sig-name descname">qemu_plugin_simple_cb_t</code><a class="headerlink" href="#c.qemu_plugin_simple_cb_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><strong>Typedef</strong>: simple callback</p>
</dd></dl>

<p><strong>Syntax</strong></p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">qemu_plugin_simple_cb_t</span> <span class="pre">(qemu_plugin_id_t</span> <span class="pre">id)</span></code></p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">qemu_plugin_id_t</span> <span class="pre">id</span></code></dt><dd><p>the unique qemu_plugin_id_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This callback passes no information aside from the unique <strong>id</strong>.</p>
<dl class="c macro">
<dt id="c.qemu_plugin_udata_cb_t">
<code class="sig-name descname">qemu_plugin_udata_cb_t</code><a class="headerlink" href="#c.qemu_plugin_udata_cb_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><strong>Typedef</strong>: callback with user data</p>
</dd></dl>

<p><strong>Syntax</strong></p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">qemu_plugin_udata_cb_t</span> <span class="pre">(qemu_plugin_id_t</span> <span class="pre">id,</span> <span class="pre">void</span> <span class="pre">*userdata)</span></code></p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">qemu_plugin_id_t</span> <span class="pre">id</span></code></dt><dd><p>the unique qemu_plugin_id_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*userdata</span></code></dt><dd><p>a pointer to some user data supplied when the callback
was registered.</p>
</dd>
</dl>
<dl class="c macro">
<dt id="c.qemu_plugin_vcpu_simple_cb_t">
<code class="sig-name descname">qemu_plugin_vcpu_simple_cb_t</code><a class="headerlink" href="#c.qemu_plugin_vcpu_simple_cb_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><strong>Typedef</strong>: vcpu callback</p>
</dd></dl>

<p><strong>Syntax</strong></p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">qemu_plugin_vcpu_simple_cb_t</span> <span class="pre">(qemu_plugin_id_t</span> <span class="pre">id,</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">vcpu_index)</span></code></p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">qemu_plugin_id_t</span> <span class="pre">id</span></code></dt><dd><p>the unique qemu_plugin_id_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">vcpu_index</span></code></dt><dd><p>the current vcpu context</p>
</dd>
</dl>
<dl class="c macro">
<dt id="c.qemu_plugin_vcpu_udata_cb_t">
<code class="sig-name descname">qemu_plugin_vcpu_udata_cb_t</code><a class="headerlink" href="#c.qemu_plugin_vcpu_udata_cb_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><strong>Typedef</strong>: vcpu callback</p>
</dd></dl>

<p><strong>Syntax</strong></p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">qemu_plugin_vcpu_udata_cb_t</span> <span class="pre">(unsigned</span> <span class="pre">int</span> <span class="pre">vcpu_index,</span> <span class="pre">void</span> <span class="pre">*userdata)</span></code></p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">vcpu_index</span></code></dt><dd><p>the current vcpu context</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*userdata</span></code></dt><dd><p>a pointer to some user data supplied when the callback
was registered.</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.qemu_plugin_uninstall">
void <code class="sig-name descname">qemu_plugin_uninstall</code><span class="sig-paren">(</span><a class="reference internal" href="#c.qemu_plugin_id_t" title="qemu_plugin_id_t">qemu_plugin_id_t</a> <em>id</em>, <a class="reference internal" href="#c.qemu_plugin_simple_cb_t" title="qemu_plugin_simple_cb_t">qemu_plugin_simple_cb_t</a> <em>cb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.qemu_plugin_uninstall" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Uninstall a plugin</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">qemu_plugin_id_t</span> <span class="pre">id</span></code></dt><dd><p>this plugin’s opaque ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">qemu_plugin_simple_cb_t</span> <span class="pre">cb</span></code></dt><dd><p>callback to be called once the plugin has been removed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Do NOT assume that the plugin has been uninstalled once this function
returns. Plugins are uninstalled asynchronously, and therefore the given
plugin receives callbacks until <strong>cb</strong> is called.</p>
<p><strong>Note</strong></p>
<p>Calling this function from qemu_plugin_install() is a bug.</p>
<dl class="c function">
<dt id="c.qemu_plugin_reset">
void <code class="sig-name descname">qemu_plugin_reset</code><span class="sig-paren">(</span><a class="reference internal" href="#c.qemu_plugin_id_t" title="qemu_plugin_id_t">qemu_plugin_id_t</a> <em>id</em>, <a class="reference internal" href="#c.qemu_plugin_simple_cb_t" title="qemu_plugin_simple_cb_t">qemu_plugin_simple_cb_t</a> <em>cb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.qemu_plugin_reset" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Reset a plugin</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">qemu_plugin_id_t</span> <span class="pre">id</span></code></dt><dd><p>this plugin’s opaque ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">qemu_plugin_simple_cb_t</span> <span class="pre">cb</span></code></dt><dd><p>callback to be called once the plugin has been reset</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unregisters all callbacks for the plugin given by <strong>id</strong>.</p>
<p>Do NOT assume that the plugin has been reset once this function returns.
Plugins are reset asynchronously, and therefore the given plugin receives
callbacks until <strong>cb</strong> is called.</p>
<dl class="c function">
<dt id="c.qemu_plugin_register_vcpu_init_cb">
void <code class="sig-name descname">qemu_plugin_register_vcpu_init_cb</code><span class="sig-paren">(</span><a class="reference internal" href="#c.qemu_plugin_id_t" title="qemu_plugin_id_t">qemu_plugin_id_t</a> <em>id</em>, <a class="reference internal" href="#c.qemu_plugin_vcpu_simple_cb_t" title="qemu_plugin_vcpu_simple_cb_t">qemu_plugin_vcpu_simple_cb_t</a> <em>cb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.qemu_plugin_register_vcpu_init_cb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>register a vCPU initialization callback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">qemu_plugin_id_t</span> <span class="pre">id</span></code></dt><dd><p>plugin ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">qemu_plugin_vcpu_simple_cb_t</span> <span class="pre">cb</span></code></dt><dd><p>callback function</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <strong>cb</strong> function is called every time a vCPU is initialized.</p>
<p>See also: qemu_plugin_register_vcpu_exit_cb()</p>
<dl class="c function">
<dt id="c.qemu_plugin_register_vcpu_exit_cb">
void <code class="sig-name descname">qemu_plugin_register_vcpu_exit_cb</code><span class="sig-paren">(</span><a class="reference internal" href="#c.qemu_plugin_id_t" title="qemu_plugin_id_t">qemu_plugin_id_t</a> <em>id</em>, <a class="reference internal" href="#c.qemu_plugin_vcpu_simple_cb_t" title="qemu_plugin_vcpu_simple_cb_t">qemu_plugin_vcpu_simple_cb_t</a> <em>cb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.qemu_plugin_register_vcpu_exit_cb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>register a vCPU exit callback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">qemu_plugin_id_t</span> <span class="pre">id</span></code></dt><dd><p>plugin ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">qemu_plugin_vcpu_simple_cb_t</span> <span class="pre">cb</span></code></dt><dd><p>callback function</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <strong>cb</strong> function is called every time a vCPU exits.</p>
<p>See also: qemu_plugin_register_vcpu_init_cb()</p>
<dl class="c function">
<dt id="c.qemu_plugin_register_vcpu_idle_cb">
void <code class="sig-name descname">qemu_plugin_register_vcpu_idle_cb</code><span class="sig-paren">(</span><a class="reference internal" href="#c.qemu_plugin_id_t" title="qemu_plugin_id_t">qemu_plugin_id_t</a> <em>id</em>, <a class="reference internal" href="#c.qemu_plugin_vcpu_simple_cb_t" title="qemu_plugin_vcpu_simple_cb_t">qemu_plugin_vcpu_simple_cb_t</a> <em>cb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.qemu_plugin_register_vcpu_idle_cb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>register a vCPU idle callback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">qemu_plugin_id_t</span> <span class="pre">id</span></code></dt><dd><p>plugin ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">qemu_plugin_vcpu_simple_cb_t</span> <span class="pre">cb</span></code></dt><dd><p>callback function</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <strong>cb</strong> function is called every time a vCPU idles.</p>
<dl class="c function">
<dt id="c.qemu_plugin_register_vcpu_resume_cb">
void <code class="sig-name descname">qemu_plugin_register_vcpu_resume_cb</code><span class="sig-paren">(</span><a class="reference internal" href="#c.qemu_plugin_id_t" title="qemu_plugin_id_t">qemu_plugin_id_t</a> <em>id</em>, <a class="reference internal" href="#c.qemu_plugin_vcpu_simple_cb_t" title="qemu_plugin_vcpu_simple_cb_t">qemu_plugin_vcpu_simple_cb_t</a> <em>cb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.qemu_plugin_register_vcpu_resume_cb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>register a vCPU resume callback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">qemu_plugin_id_t</span> <span class="pre">id</span></code></dt><dd><p>plugin ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">qemu_plugin_vcpu_simple_cb_t</span> <span class="pre">cb</span></code></dt><dd><p>callback function</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <strong>cb</strong> function is called every time a vCPU resumes execution.</p>
<dl class="c enum">
<dt id="c.qemu_plugin_cb_flags">
<em class="property">enum </em><code class="sig-name descname">qemu_plugin_cb_flags</code><a class="headerlink" href="#c.qemu_plugin_cb_flags" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>type of callback</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">QEMU_PLUGIN_CB_NO_REGS</span></code></dt><dd><p>callback does not access the CPU’s regs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">QEMU_PLUGIN_CB_R_REGS</span></code></dt><dd><p>callback reads the CPU’s regs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">QEMU_PLUGIN_CB_RW_REGS</span></code></dt><dd><p>callback reads and writes the CPU’s regs</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>currently unused, plugins cannot read or change system
register state.</p>
<dl class="c macro">
<dt id="c.qemu_plugin_vcpu_tb_trans_cb_t">
<code class="sig-name descname">qemu_plugin_vcpu_tb_trans_cb_t</code><a class="headerlink" href="#c.qemu_plugin_vcpu_tb_trans_cb_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><strong>Typedef</strong>: translation callback</p>
</dd></dl>

<p><strong>Syntax</strong></p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">qemu_plugin_vcpu_tb_trans_cb_t</span> <span class="pre">(qemu_plugin_id_t</span> <span class="pre">id,</span> <span class="pre">struct</span> <span class="pre">qemu_plugin_tb</span> <span class="pre">*tb)</span></code></p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">qemu_plugin_id_t</span> <span class="pre">id</span></code></dt><dd><p>unique plugin id</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">qemu_plugin_tb</span> <span class="pre">*tb</span></code></dt><dd><p>opaque handle used for querying and instrumenting a block.</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.qemu_plugin_register_vcpu_tb_trans_cb">
void <code class="sig-name descname">qemu_plugin_register_vcpu_tb_trans_cb</code><span class="sig-paren">(</span><a class="reference internal" href="#c.qemu_plugin_id_t" title="qemu_plugin_id_t">qemu_plugin_id_t</a> <em>id</em>, <a class="reference internal" href="#c.qemu_plugin_vcpu_tb_trans_cb_t" title="qemu_plugin_vcpu_tb_trans_cb_t">qemu_plugin_vcpu_tb_trans_cb_t</a> <em>cb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.qemu_plugin_register_vcpu_tb_trans_cb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>register a translate cb</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">qemu_plugin_id_t</span> <span class="pre">id</span></code></dt><dd><p>plugin ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">qemu_plugin_vcpu_tb_trans_cb_t</span> <span class="pre">cb</span></code></dt><dd><p>callback function</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <strong>cb</strong> function is called every time a translation occurs. The <strong>cb</strong>
function is passed an opaque qemu_plugin_type which it can query
for additional information including the list of translated
instructions. At this point the plugin can register further
callbacks to be triggered when the block or individual instruction
executes.</p>
<dl class="c function">
<dt id="c.qemu_plugin_register_vcpu_tb_exec_cb">
void <code class="sig-name descname">qemu_plugin_register_vcpu_tb_exec_cb</code><span class="sig-paren">(</span><em class="property">struct</em> qemu_plugin_tb *<em>tb</em>, <a class="reference internal" href="#c.qemu_plugin_vcpu_udata_cb_t" title="qemu_plugin_vcpu_udata_cb_t">qemu_plugin_vcpu_udata_cb_t</a> <em>cb</em>, <em class="property">enum</em> <a class="reference internal" href="#c.qemu_plugin_cb_flags" title="qemu_plugin_cb_flags">qemu_plugin_cb_flags</a> <em>flags</em>, void *<em>userdata</em><span class="sig-paren">)</span><a class="headerlink" href="#c.qemu_plugin_register_vcpu_tb_exec_cb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>register execution callback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">qemu_plugin_tb</span> <span class="pre">*tb</span></code></dt><dd><p>the opaque qemu_plugin_tb handle for the translation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">qemu_plugin_vcpu_udata_cb_t</span> <span class="pre">cb</span></code></dt><dd><p>callback function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">qemu_plugin_cb_flags</span> <span class="pre">flags</span></code></dt><dd><p>does the plugin read or write the CPU’s registers?</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*userdata</span></code></dt><dd><p>any plugin data to pass to the <strong>cb</strong>?</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <strong>cb</strong> function is called every time a translated unit executes.</p>
<dl class="c enum">
<dt id="c.qemu_plugin_op">
<em class="property">enum </em><code class="sig-name descname">qemu_plugin_op</code><a class="headerlink" href="#c.qemu_plugin_op" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>describes an inline op</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">QEMU_PLUGIN_INLINE_ADD_U64</span></code></dt><dd><p>add an immediate value uint64_t</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>currently only a single inline op is supported.</p>
<dl class="c function">
<dt id="c.qemu_plugin_register_vcpu_tb_exec_inline">
void <code class="sig-name descname">qemu_plugin_register_vcpu_tb_exec_inline</code><span class="sig-paren">(</span><em class="property">struct</em> qemu_plugin_tb *<em>tb</em>, <em class="property">enum</em> <a class="reference internal" href="#c.qemu_plugin_op" title="qemu_plugin_op">qemu_plugin_op</a> <em>op</em>, void *<em>ptr</em>, uint64_t <em>imm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.qemu_plugin_register_vcpu_tb_exec_inline" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>execution inline op</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">qemu_plugin_tb</span> <span class="pre">*tb</span></code></dt><dd><p>the opaque qemu_plugin_tb handle for the translation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">qemu_plugin_op</span> <span class="pre">op</span></code></dt><dd><p>the type of qemu_plugin_op (e.g. ADD_U64)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*ptr</span></code></dt><dd><p>the target memory location for the op</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">imm</span></code></dt><dd><p>the op data (e.g. 1)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Insert an inline op to every time a translated unit executes.
Useful if you just want to increment a single counter somewhere in
memory.</p>
<p><strong>Note</strong></p>
<p>ops are not atomic so in multi-threaded/multi-smp situations
you will get inexact results.</p>
<dl class="c function">
<dt id="c.qemu_plugin_register_vcpu_insn_exec_cb">
void <code class="sig-name descname">qemu_plugin_register_vcpu_insn_exec_cb</code><span class="sig-paren">(</span><em class="property">struct</em> qemu_plugin_insn *<em>insn</em>, <a class="reference internal" href="#c.qemu_plugin_vcpu_udata_cb_t" title="qemu_plugin_vcpu_udata_cb_t">qemu_plugin_vcpu_udata_cb_t</a> <em>cb</em>, <em class="property">enum</em> <a class="reference internal" href="#c.qemu_plugin_cb_flags" title="qemu_plugin_cb_flags">qemu_plugin_cb_flags</a> <em>flags</em>, void *<em>userdata</em><span class="sig-paren">)</span><a class="headerlink" href="#c.qemu_plugin_register_vcpu_insn_exec_cb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>register insn execution cb</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">qemu_plugin_insn</span> <span class="pre">*insn</span></code></dt><dd><p>the opaque qemu_plugin_insn handle for an instruction</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">qemu_plugin_vcpu_udata_cb_t</span> <span class="pre">cb</span></code></dt><dd><p>callback function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">qemu_plugin_cb_flags</span> <span class="pre">flags</span></code></dt><dd><p>does the plugin read or write the CPU’s registers?</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*userdata</span></code></dt><dd><p>any plugin data to pass to the <strong>cb</strong>?</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <strong>cb</strong> function is called every time an instruction is executed</p>
<dl class="c function">
<dt id="c.qemu_plugin_register_vcpu_insn_exec_inline">
void <code class="sig-name descname">qemu_plugin_register_vcpu_insn_exec_inline</code><span class="sig-paren">(</span><em class="property">struct</em> qemu_plugin_insn *<em>insn</em>, <em class="property">enum</em> <a class="reference internal" href="#c.qemu_plugin_op" title="qemu_plugin_op">qemu_plugin_op</a> <em>op</em>, void *<em>ptr</em>, uint64_t <em>imm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.qemu_plugin_register_vcpu_insn_exec_inline" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>insn execution inline op</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">qemu_plugin_insn</span> <span class="pre">*insn</span></code></dt><dd><p>the opaque qemu_plugin_insn handle for an instruction</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">qemu_plugin_op</span> <span class="pre">op</span></code></dt><dd><p>the type of qemu_plugin_op (e.g. ADD_U64)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*ptr</span></code></dt><dd><p>the target memory location for the op</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">imm</span></code></dt><dd><p>the op data (e.g. 1)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Insert an inline op to every time an instruction executes. Useful
if you just want to increment a single counter somewhere in memory.</p>
<dl class="c function">
<dt id="c.qemu_plugin_tb_n_insns">
size_t <code class="sig-name descname">qemu_plugin_tb_n_insns</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> qemu_plugin_tb *<em>tb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.qemu_plugin_tb_n_insns" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>query helper for number of insns in TB</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">qemu_plugin_tb</span> <span class="pre">*tb</span></code></dt><dd><p>opaque handle to TB passed to callback</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>number of instructions in this block</p>
<dl class="c function">
<dt id="c.qemu_plugin_tb_vaddr">
uint64_t <code class="sig-name descname">qemu_plugin_tb_vaddr</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> qemu_plugin_tb *<em>tb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.qemu_plugin_tb_vaddr" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>query helper for vaddr of TB start</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">qemu_plugin_tb</span> <span class="pre">*tb</span></code></dt><dd><p>opaque handle to TB passed to callback</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>virtual address of block start</p>
<dl class="c function">
<dt id="c.qemu_plugin_tb_get_insn">
<em class="property">struct</em> qemu_plugin_insn *<code class="sig-name descname">qemu_plugin_tb_get_insn</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> qemu_plugin_tb *<em>tb</em>, size_t <em>idx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.qemu_plugin_tb_get_insn" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>retrieve handle for instruction</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">qemu_plugin_tb</span> <span class="pre">*tb</span></code></dt><dd><p>opaque handle to TB passed to callback</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">idx</span></code></dt><dd><p>instruction number, 0 indexed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The returned handle can be used in follow up helper queries as well
as when instrumenting an instruction. It is only valid for the
lifetime of the callback.</p>
<p><strong>Return</strong></p>
<p>opaque handle to instruction</p>
<dl class="c function">
<dt id="c.qemu_plugin_insn_data">
<em class="property">const</em> void *<code class="sig-name descname">qemu_plugin_insn_data</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> qemu_plugin_insn *<em>insn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.qemu_plugin_insn_data" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>return ptr to instruction data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">qemu_plugin_insn</span> <span class="pre">*insn</span></code></dt><dd><p>opaque instruction handle from qemu_plugin_tb_get_insn()</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>data is only valid for duration of callback. See
qemu_plugin_insn_size() to calculate size of stream.</p>
<p><strong>Return</strong></p>
<p>pointer to a stream of bytes containing the value of this
instructions opcode.</p>
<dl class="c function">
<dt id="c.qemu_plugin_insn_size">
size_t <code class="sig-name descname">qemu_plugin_insn_size</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> qemu_plugin_insn *<em>insn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.qemu_plugin_insn_size" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>return size of instruction</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">qemu_plugin_insn</span> <span class="pre">*insn</span></code></dt><dd><p>opaque instruction handle from qemu_plugin_tb_get_insn()</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>size of instruction in bytes</p>
<dl class="c function">
<dt id="c.qemu_plugin_insn_vaddr">
uint64_t <code class="sig-name descname">qemu_plugin_insn_vaddr</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> qemu_plugin_insn *<em>insn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.qemu_plugin_insn_vaddr" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>return vaddr of instruction</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">qemu_plugin_insn</span> <span class="pre">*insn</span></code></dt><dd><p>opaque instruction handle from qemu_plugin_tb_get_insn()</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>virtual address of instruction</p>
<dl class="c function">
<dt id="c.qemu_plugin_insn_haddr">
void *<code class="sig-name descname">qemu_plugin_insn_haddr</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> qemu_plugin_insn *<em>insn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.qemu_plugin_insn_haddr" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>return hardware addr of instruction</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">qemu_plugin_insn</span> <span class="pre">*insn</span></code></dt><dd><p>opaque instruction handle from qemu_plugin_tb_get_insn()</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>hardware (physical) target address of instruction</p>
<dl class="c type">
<dt id="c.qemu_plugin_meminfo_t">
<em class="property">type </em><code class="sig-name descname">qemu_plugin_meminfo_t</code><a class="headerlink" href="#c.qemu_plugin_meminfo_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>opaque memory transaction handle</p>
</dd></dl>

<p><strong>Description</strong></p>
<p>This can be further queried using the qemu_plugin_mem_* query
functions.</p>
<dl class="c function">
<dt id="c.qemu_plugin_mem_size_shift">
unsigned int <code class="sig-name descname">qemu_plugin_mem_size_shift</code><span class="sig-paren">(</span><a class="reference internal" href="#c.qemu_plugin_meminfo_t" title="qemu_plugin_meminfo_t">qemu_plugin_meminfo_t</a> <em>info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.qemu_plugin_mem_size_shift" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>get size of access</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">qemu_plugin_meminfo_t</span> <span class="pre">info</span></code></dt><dd><p>opaque memory transaction handle</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>size of access in ^2 (0=byte, 1=16bit, 2=32bit etc…)</p>
<dl class="c function">
<dt id="c.qemu_plugin_mem_is_sign_extended">
bool <code class="sig-name descname">qemu_plugin_mem_is_sign_extended</code><span class="sig-paren">(</span><a class="reference internal" href="#c.qemu_plugin_meminfo_t" title="qemu_plugin_meminfo_t">qemu_plugin_meminfo_t</a> <em>info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.qemu_plugin_mem_is_sign_extended" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>was the access sign extended</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">qemu_plugin_meminfo_t</span> <span class="pre">info</span></code></dt><dd><p>opaque memory transaction handle</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>true if it was, otherwise false</p>
<dl class="c function">
<dt id="c.qemu_plugin_mem_is_big_endian">
bool <code class="sig-name descname">qemu_plugin_mem_is_big_endian</code><span class="sig-paren">(</span><a class="reference internal" href="#c.qemu_plugin_meminfo_t" title="qemu_plugin_meminfo_t">qemu_plugin_meminfo_t</a> <em>info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.qemu_plugin_mem_is_big_endian" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>was the access big endian</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">qemu_plugin_meminfo_t</span> <span class="pre">info</span></code></dt><dd><p>opaque memory transaction handle</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>true if it was, otherwise false</p>
<dl class="c function">
<dt id="c.qemu_plugin_mem_is_store">
bool <code class="sig-name descname">qemu_plugin_mem_is_store</code><span class="sig-paren">(</span><a class="reference internal" href="#c.qemu_plugin_meminfo_t" title="qemu_plugin_meminfo_t">qemu_plugin_meminfo_t</a> <em>info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.qemu_plugin_mem_is_store" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>was the access a store</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">qemu_plugin_meminfo_t</span> <span class="pre">info</span></code></dt><dd><p>opaque memory transaction handle</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>true if it was, otherwise false</p>
<dl class="c function">
<dt id="c.qemu_plugin_get_hwaddr">
<em class="property">struct</em> qemu_plugin_hwaddr *<code class="sig-name descname">qemu_plugin_get_hwaddr</code><span class="sig-paren">(</span><a class="reference internal" href="#c.qemu_plugin_meminfo_t" title="qemu_plugin_meminfo_t">qemu_plugin_meminfo_t</a> <em>info</em>, uint64_t <em>vaddr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.qemu_plugin_get_hwaddr" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>return handle for memory operation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">qemu_plugin_meminfo_t</span> <span class="pre">info</span></code></dt><dd><p>opaque memory info structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">vaddr</span></code></dt><dd><p>the virtual address of the memory operation</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>For system emulation returns a qemu_plugin_hwaddr handle to query
details about the actual physical address backing the virtual
address. For linux-user guests it just returns NULL.</p>
<p>This handle is <em>only</em> valid for the duration of the callback. Any
information about the handle should be recovered before the
callback returns.</p>
<dl class="c function">
<dt id="c.qemu_plugin_hwaddr_is_io">
bool <code class="sig-name descname">qemu_plugin_hwaddr_is_io</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> qemu_plugin_hwaddr *<em>haddr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.qemu_plugin_hwaddr_is_io" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>query whether memory operation is IO</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">qemu_plugin_hwaddr</span> <span class="pre">*haddr</span></code></dt><dd><p>address handle from qemu_plugin_get_hwaddr()</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if the handle’s memory operation is to memory-mapped IO, or
false if it is to RAM</p>
<dl class="c function">
<dt id="c.qemu_plugin_hwaddr_phys_addr">
uint64_t <code class="sig-name descname">qemu_plugin_hwaddr_phys_addr</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> qemu_plugin_hwaddr *<em>haddr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.qemu_plugin_hwaddr_phys_addr" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>query physical address for memory operation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">qemu_plugin_hwaddr</span> <span class="pre">*haddr</span></code></dt><dd><p>address handle from qemu_plugin_get_hwaddr()</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the physical address associated with the memory operation</p>
<p>Note that the returned physical address may not be unique if you are dealing
with multiple address spaces.</p>
<dl class="c function">
<dt id="c.qemu_plugin_insn_disas">
char *<code class="sig-name descname">qemu_plugin_insn_disas</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> qemu_plugin_insn *<em>insn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.qemu_plugin_insn_disas" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>return disassembly string for instruction</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">qemu_plugin_insn</span> <span class="pre">*insn</span></code></dt><dd><p>instruction reference</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns an allocated string containing the disassembly</p>
<dl class="c function">
<dt id="c.qemu_plugin_vcpu_for_each">
void <code class="sig-name descname">qemu_plugin_vcpu_for_each</code><span class="sig-paren">(</span><a class="reference internal" href="#c.qemu_plugin_id_t" title="qemu_plugin_id_t">qemu_plugin_id_t</a> <em>id</em>, <a class="reference internal" href="#c.qemu_plugin_vcpu_simple_cb_t" title="qemu_plugin_vcpu_simple_cb_t">qemu_plugin_vcpu_simple_cb_t</a> <em>cb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.qemu_plugin_vcpu_for_each" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>iterate over the existing vCPU</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">qemu_plugin_id_t</span> <span class="pre">id</span></code></dt><dd><p>plugin ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">qemu_plugin_vcpu_simple_cb_t</span> <span class="pre">cb</span></code></dt><dd><p>callback function</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <strong>cb</strong> function is called once for each existing vCPU.</p>
<p>See also: qemu_plugin_register_vcpu_init_cb()</p>
<dl class="c function">
<dt id="c.qemu_plugin_outs">
void <code class="sig-name descname">qemu_plugin_outs</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>string</em><span class="sig-paren">)</span><a class="headerlink" href="#c.qemu_plugin_outs" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>output string via QEMU’s logging system</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*string</span></code></dt><dd><p>a string</p>
</dd>
</dl>
</div>
<div class="section" id="usage">
<h2>Usage<a class="headerlink" href="#usage" title="Permalink to this headline">¶</a></h2>
<p>The QEMU binary needs to be compiled for plugin support:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">configure</span> <span class="o">--</span><span class="n">enable</span><span class="o">-</span><span class="n">plugins</span>
</pre></div>
</div>
<p>Once built a program can be run with multiple plugins loaded each with
their own arguments:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$QEMU $OTHER_QEMU_ARGS \
    -plugin tests/plugin/libhowvec.so,arg=inline,arg=hint \
    -plugin tests/plugin/libhotblocks.so
</pre></div>
</div>
<p>Arguments are plugin specific and can be used to modify their
behaviour. In this case the howvec plugin is being asked to use inline
ops to count and break down the hint instructions by type.</p>
</div>
<div class="section" id="plugin-life-cycle">
<h2>Plugin Life cycle<a class="headerlink" href="#plugin-life-cycle" title="Permalink to this headline">¶</a></h2>
<p>First the plugin is loaded and the public qemu_plugin_install function
is called. The plugin will then register callbacks for various plugin
events. Generally plugins will register a handler for the <em>atexit</em>
if they want to dump a summary of collected information once the
program/system has finished running.</p>
<p>When a registered event occurs the plugin callback is invoked. The
callbacks may provide additional information. In the case of a
translation event the plugin has an option to enumerate the
instructions in a block of instructions and optionally register
callbacks to some or all instructions when they are executed.</p>
<p>There is also a facility to add an inline event where code to
increment a counter can be directly inlined with the translation.
Currently only a simple increment is supported. This is not atomic so
can miss counts. If you want absolute precision you should use a
callback which can then ensure atomicity itself.</p>
<p>Finally when QEMU exits all the registered <em>atexit</em> callbacks are
invoked.</p>
</div>
<div class="section" id="internals">
<h2>Internals<a class="headerlink" href="#internals" title="Permalink to this headline">¶</a></h2>
<div class="section" id="locking">
<h3>Locking<a class="headerlink" href="#locking" title="Permalink to this headline">¶</a></h3>
<p>We have to ensure we cannot deadlock, particularly under MTTCG. For
this we acquire a lock when called from plugin code. We also keep the
list of callbacks under RCU so that we do not have to hold the lock
when calling the callbacks. This is also for performance, since some
callbacks (e.g. memory access callbacks) might be called very
frequently.</p>
<blockquote>
<div><ul class="simple">
<li><p>A consequence of this is that we keep our own list of CPUs, so that
we do not have to worry about locking order wrt cpu_list_lock.</p></li>
<li><p>Use a recursive lock, since we can get registration calls from
callbacks.</p></li>
</ul>
</div></blockquote>
<p>As a result registering/unregistering callbacks is “slow”, since it
takes a lock. But this is very infrequent; we want performance when
calling (or not calling) callbacks, not when registering them. Using
RCU is great for this.</p>
<p>We support the uninstallation of a plugin at any time (e.g. from
plugin callbacks). This allows plugins to remove themselves if they no
longer want to instrument the code. This operation is asynchronous
which means callbacks may still occur after the uninstall operation is
requested. The plugin isn’t completely uninstalled until the safe work
has executed while all vCPUs are quiescent.</p>
</div>
</div>
<div class="section" id="example-plugins">
<h2>Example Plugins<a class="headerlink" href="#example-plugins" title="Permalink to this headline">¶</a></h2>
<p>There are a number of plugins included with QEMU and you are
encouraged to contribute your own plugins plugins upstream. There is a
<cite>contrib/plugins</cite> directory where they can go.</p>
<ul class="simple">
<li><p>tests/plugins</p></li>
</ul>
<p>These are some basic plugins that are used to test and exercise the
API during the <cite>make check-tcg</cite> target.</p>
<ul class="simple">
<li><p>contrib/plugins/hotblocks.c</p></li>
</ul>
<p>The hotblocks plugin allows you to examine the where hot paths of
execution are in your program. Once the program has finished you will
get a sorted list of blocks reporting the starting PC, translation
count, number of instructions and execution count. This will work best
with linux-user execution as system emulation tends to generate
re-translations as blocks from different programs get swapped in and
out of system memory.</p>
<p>If your program is single-threaded you can use the <cite>inline</cite> option for
slightly faster (but not thread safe) counters.</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">./</span><span class="n">aarch64</span><span class="o">-</span><span class="n">linux</span><span class="o">-</span><span class="n">user</span><span class="o">/</span><span class="n">qemu</span><span class="o">-</span><span class="n">aarch64</span> \
  <span class="o">-</span><span class="n">plugin</span> <span class="n">contrib</span><span class="o">/</span><span class="n">plugins</span><span class="o">/</span><span class="n">libhotblocks</span><span class="o">.</span><span class="n">so</span> <span class="o">-</span><span class="n">d</span> <span class="n">plugin</span> \
  <span class="o">./</span><span class="n">tests</span><span class="o">/</span><span class="n">tcg</span><span class="o">/</span><span class="n">aarch64</span><span class="o">-</span><span class="n">linux</span><span class="o">-</span><span class="n">user</span><span class="o">/</span><span class="n">sha1</span>
<span class="n">SHA1</span><span class="o">=</span><span class="mi">15</span><span class="n">dd99a1991e0b3826fede3deffc1feba42278e6</span>
<span class="n">collected</span> <span class="mi">903</span> <span class="n">entries</span> <span class="ow">in</span> <span class="n">the</span> <span class="nb">hash</span> <span class="n">table</span>
<span class="n">pc</span><span class="p">,</span> <span class="n">tcount</span><span class="p">,</span> <span class="n">icount</span><span class="p">,</span> <span class="n">ecount</span>
<span class="mh">0x0000000041ed10</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">66087</span>
<span class="mh">0x000000004002b0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">66087</span>
<span class="o">...</span>
</pre></div>
</div>
<ul class="simple">
<li><p>contrib/plugins/hotpages.c</p></li>
</ul>
<p>Similar to hotblocks but this time tracks memory accesses:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">./</span><span class="n">aarch64</span><span class="o">-</span><span class="n">linux</span><span class="o">-</span><span class="n">user</span><span class="o">/</span><span class="n">qemu</span><span class="o">-</span><span class="n">aarch64</span> \
  <span class="o">-</span><span class="n">plugin</span> <span class="n">contrib</span><span class="o">/</span><span class="n">plugins</span><span class="o">/</span><span class="n">libhotpages</span><span class="o">.</span><span class="n">so</span> <span class="o">-</span><span class="n">d</span> <span class="n">plugin</span> \
  <span class="o">./</span><span class="n">tests</span><span class="o">/</span><span class="n">tcg</span><span class="o">/</span><span class="n">aarch64</span><span class="o">-</span><span class="n">linux</span><span class="o">-</span><span class="n">user</span><span class="o">/</span><span class="n">sha1</span>
<span class="n">SHA1</span><span class="o">=</span><span class="mi">15</span><span class="n">dd99a1991e0b3826fede3deffc1feba42278e6</span>
<span class="n">Addr</span><span class="p">,</span> <span class="n">RCPUs</span><span class="p">,</span> <span class="n">Reads</span><span class="p">,</span> <span class="n">WCPUs</span><span class="p">,</span> <span class="n">Writes</span>
<span class="mh">0x000055007fe000</span><span class="p">,</span> <span class="mh">0x0001</span><span class="p">,</span> <span class="mi">31747952</span><span class="p">,</span> <span class="mh">0x0001</span><span class="p">,</span> <span class="mi">8835161</span>
<span class="mh">0x000055007ff000</span><span class="p">,</span> <span class="mh">0x0001</span><span class="p">,</span> <span class="mi">29001054</span><span class="p">,</span> <span class="mh">0x0001</span><span class="p">,</span> <span class="mi">8780625</span>
<span class="mh">0x00005500800000</span><span class="p">,</span> <span class="mh">0x0001</span><span class="p">,</span> <span class="mi">687465</span><span class="p">,</span> <span class="mh">0x0001</span><span class="p">,</span> <span class="mi">335857</span>
<span class="mh">0x0000000048b000</span><span class="p">,</span> <span class="mh">0x0001</span><span class="p">,</span> <span class="mi">130594</span><span class="p">,</span> <span class="mh">0x0001</span><span class="p">,</span> <span class="mi">355</span>
<span class="mh">0x0000000048a000</span><span class="p">,</span> <span class="mh">0x0001</span><span class="p">,</span> <span class="mi">1826</span><span class="p">,</span> <span class="mh">0x0001</span><span class="p">,</span> <span class="mi">11</span>
</pre></div>
</div>
<ul class="simple">
<li><p>contrib/plugins/howvec.c</p></li>
</ul>
<p>This is an instruction classifier so can be used to count different
types of instructions. It has a number of options to refine which get
counted. You can give an argument for a class of instructions to break
it down fully, so for example to see all the system registers
accesses:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>./aarch64-softmmu/qemu-system-aarch64 $(QEMU_ARGS) \
  -append &quot;root=/dev/sda2 systemd.unit=benchmark.service&quot; \
  -smp 4 -plugin ./contrib/plugins/libhowvec.so,arg=sreg -d plugin
</pre></div>
</div>
<p>which will lead to a sorted list after the class breakdown:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Instruction</span> <span class="n">Classes</span><span class="p">:</span>
<span class="n">Class</span><span class="p">:</span>   <span class="n">UDEF</span>                   <span class="ow">not</span> <span class="n">counted</span>
<span class="n">Class</span><span class="p">:</span>   <span class="n">SVE</span>                    <span class="p">(</span><span class="mi">68</span> <span class="n">hits</span><span class="p">)</span>
<span class="n">Class</span><span class="p">:</span>   <span class="n">PCrel</span> <span class="n">addr</span>             <span class="p">(</span><span class="mi">47789483</span> <span class="n">hits</span><span class="p">)</span>
<span class="n">Class</span><span class="p">:</span>   <span class="n">Add</span><span class="o">/</span><span class="n">Sub</span> <span class="p">(</span><span class="n">imm</span><span class="p">)</span>          <span class="p">(</span><span class="mi">192817388</span> <span class="n">hits</span><span class="p">)</span>
<span class="n">Class</span><span class="p">:</span>   <span class="n">Logical</span> <span class="p">(</span><span class="n">imm</span><span class="p">)</span>          <span class="p">(</span><span class="mi">93852565</span> <span class="n">hits</span><span class="p">)</span>
<span class="n">Class</span><span class="p">:</span>   <span class="n">Move</span> <span class="n">Wide</span> <span class="p">(</span><span class="n">imm</span><span class="p">)</span>        <span class="p">(</span><span class="mi">76398116</span> <span class="n">hits</span><span class="p">)</span>
<span class="n">Class</span><span class="p">:</span>   <span class="n">Bitfield</span>               <span class="p">(</span><span class="mi">44706084</span> <span class="n">hits</span><span class="p">)</span>
<span class="n">Class</span><span class="p">:</span>   <span class="n">Extract</span>                <span class="p">(</span><span class="mi">5499257</span> <span class="n">hits</span><span class="p">)</span>
<span class="n">Class</span><span class="p">:</span>   <span class="n">Cond</span> <span class="n">Branch</span> <span class="p">(</span><span class="n">imm</span><span class="p">)</span>      <span class="p">(</span><span class="mi">147202932</span> <span class="n">hits</span><span class="p">)</span>
<span class="n">Class</span><span class="p">:</span>   <span class="ne">Exception</span> <span class="n">Gen</span>          <span class="p">(</span><span class="mi">193581</span> <span class="n">hits</span><span class="p">)</span>
<span class="n">Class</span><span class="p">:</span>     <span class="n">NOP</span>                  <span class="ow">not</span> <span class="n">counted</span>
<span class="n">Class</span><span class="p">:</span>   <span class="n">Hints</span>                  <span class="p">(</span><span class="mi">6652291</span> <span class="n">hits</span><span class="p">)</span>
<span class="n">Class</span><span class="p">:</span>   <span class="n">Barriers</span>               <span class="p">(</span><span class="mi">8001661</span> <span class="n">hits</span><span class="p">)</span>
<span class="n">Class</span><span class="p">:</span>   <span class="n">PSTATE</span>                 <span class="p">(</span><span class="mi">1801695</span> <span class="n">hits</span><span class="p">)</span>
<span class="n">Class</span><span class="p">:</span>   <span class="n">System</span> <span class="n">Insn</span>            <span class="p">(</span><span class="mi">6385349</span> <span class="n">hits</span><span class="p">)</span>
<span class="n">Class</span><span class="p">:</span>   <span class="n">System</span> <span class="n">Reg</span>             <span class="n">counted</span> <span class="n">individually</span>
<span class="n">Class</span><span class="p">:</span>   <span class="n">Branch</span> <span class="p">(</span><span class="n">reg</span><span class="p">)</span>           <span class="p">(</span><span class="mi">69497127</span> <span class="n">hits</span><span class="p">)</span>
<span class="n">Class</span><span class="p">:</span>   <span class="n">Branch</span> <span class="p">(</span><span class="n">imm</span><span class="p">)</span>           <span class="p">(</span><span class="mi">84393665</span> <span class="n">hits</span><span class="p">)</span>
<span class="n">Class</span><span class="p">:</span>   <span class="n">Cmp</span> <span class="o">&amp;</span> <span class="n">Branch</span>           <span class="p">(</span><span class="mi">110929659</span> <span class="n">hits</span><span class="p">)</span>
<span class="n">Class</span><span class="p">:</span>   <span class="n">Tst</span> <span class="o">&amp;</span> <span class="n">Branch</span>           <span class="p">(</span><span class="mi">44681442</span> <span class="n">hits</span><span class="p">)</span>
<span class="n">Class</span><span class="p">:</span>   <span class="n">AdvSimd</span> <span class="n">ldstmult</span>       <span class="p">(</span><span class="mi">736</span> <span class="n">hits</span><span class="p">)</span>
<span class="n">Class</span><span class="p">:</span>   <span class="n">ldst</span> <span class="n">excl</span>              <span class="p">(</span><span class="mi">9098783</span> <span class="n">hits</span><span class="p">)</span>
<span class="n">Class</span><span class="p">:</span>   <span class="n">Load</span> <span class="n">Reg</span> <span class="p">(</span><span class="n">lit</span><span class="p">)</span>         <span class="p">(</span><span class="mi">87189424</span> <span class="n">hits</span><span class="p">)</span>
<span class="n">Class</span><span class="p">:</span>   <span class="n">ldst</span> <span class="n">noalloc</span> <span class="n">pair</span>      <span class="p">(</span><span class="mi">3264433</span> <span class="n">hits</span><span class="p">)</span>
<span class="n">Class</span><span class="p">:</span>   <span class="n">ldst</span> <span class="n">pair</span>              <span class="p">(</span><span class="mi">412526434</span> <span class="n">hits</span><span class="p">)</span>
<span class="n">Class</span><span class="p">:</span>   <span class="n">ldst</span> <span class="n">reg</span> <span class="p">(</span><span class="n">imm</span><span class="p">)</span>         <span class="p">(</span><span class="mi">314734576</span> <span class="n">hits</span><span class="p">)</span>
<span class="n">Class</span><span class="p">:</span> <span class="n">Loads</span> <span class="o">&amp;</span> <span class="n">Stores</span>           <span class="p">(</span><span class="mi">2117774</span> <span class="n">hits</span><span class="p">)</span>
<span class="n">Class</span><span class="p">:</span> <span class="n">Data</span> <span class="n">Proc</span> <span class="n">Reg</span>            <span class="p">(</span><span class="mi">223519077</span> <span class="n">hits</span><span class="p">)</span>
<span class="n">Class</span><span class="p">:</span> <span class="n">Scalar</span> <span class="n">FP</span>                <span class="p">(</span><span class="mi">31657954</span> <span class="n">hits</span><span class="p">)</span>
<span class="n">Individual</span> <span class="n">Instructions</span><span class="p">:</span>
<span class="n">Instr</span><span class="p">:</span> <span class="n">mrs</span> <span class="n">x0</span><span class="p">,</span> <span class="n">sp_el0</span>           <span class="p">(</span><span class="mi">2682661</span> <span class="n">hits</span><span class="p">)</span>  <span class="p">(</span><span class="n">op</span><span class="o">=</span><span class="mh">0xd5384100</span><span class="o">/</span>  <span class="n">System</span> <span class="n">Reg</span><span class="p">)</span>
<span class="n">Instr</span><span class="p">:</span> <span class="n">mrs</span> <span class="n">x1</span><span class="p">,</span> <span class="n">tpidr_el2</span>        <span class="p">(</span><span class="mi">1789339</span> <span class="n">hits</span><span class="p">)</span>  <span class="p">(</span><span class="n">op</span><span class="o">=</span><span class="mh">0xd53cd041</span><span class="o">/</span>  <span class="n">System</span> <span class="n">Reg</span><span class="p">)</span>
<span class="n">Instr</span><span class="p">:</span> <span class="n">mrs</span> <span class="n">x2</span><span class="p">,</span> <span class="n">tpidr_el2</span>        <span class="p">(</span><span class="mi">1513494</span> <span class="n">hits</span><span class="p">)</span>  <span class="p">(</span><span class="n">op</span><span class="o">=</span><span class="mh">0xd53cd042</span><span class="o">/</span>  <span class="n">System</span> <span class="n">Reg</span><span class="p">)</span>
<span class="n">Instr</span><span class="p">:</span> <span class="n">mrs</span> <span class="n">x0</span><span class="p">,</span> <span class="n">tpidr_el2</span>        <span class="p">(</span><span class="mi">1490823</span> <span class="n">hits</span><span class="p">)</span>  <span class="p">(</span><span class="n">op</span><span class="o">=</span><span class="mh">0xd53cd040</span><span class="o">/</span>  <span class="n">System</span> <span class="n">Reg</span><span class="p">)</span>
<span class="n">Instr</span><span class="p">:</span> <span class="n">mrs</span> <span class="n">x1</span><span class="p">,</span> <span class="n">sp_el0</span>           <span class="p">(</span><span class="mi">933793</span> <span class="n">hits</span><span class="p">)</span>   <span class="p">(</span><span class="n">op</span><span class="o">=</span><span class="mh">0xd5384101</span><span class="o">/</span>  <span class="n">System</span> <span class="n">Reg</span><span class="p">)</span>
<span class="n">Instr</span><span class="p">:</span> <span class="n">mrs</span> <span class="n">x2</span><span class="p">,</span> <span class="n">sp_el0</span>           <span class="p">(</span><span class="mi">699516</span> <span class="n">hits</span><span class="p">)</span>   <span class="p">(</span><span class="n">op</span><span class="o">=</span><span class="mh">0xd5384102</span><span class="o">/</span>  <span class="n">System</span> <span class="n">Reg</span><span class="p">)</span>
<span class="n">Instr</span><span class="p">:</span> <span class="n">mrs</span> <span class="n">x4</span><span class="p">,</span> <span class="n">tpidr_el2</span>        <span class="p">(</span><span class="mi">528437</span> <span class="n">hits</span><span class="p">)</span>   <span class="p">(</span><span class="n">op</span><span class="o">=</span><span class="mh">0xd53cd044</span><span class="o">/</span>  <span class="n">System</span> <span class="n">Reg</span><span class="p">)</span>
<span class="n">Instr</span><span class="p">:</span> <span class="n">mrs</span> <span class="n">x30</span><span class="p">,</span> <span class="n">ttbr1_el1</span>       <span class="p">(</span><span class="mi">480776</span> <span class="n">hits</span><span class="p">)</span>   <span class="p">(</span><span class="n">op</span><span class="o">=</span><span class="mh">0xd538203e</span><span class="o">/</span>  <span class="n">System</span> <span class="n">Reg</span><span class="p">)</span>
<span class="n">Instr</span><span class="p">:</span> <span class="n">msr</span> <span class="n">ttbr1_el1</span><span class="p">,</span> <span class="n">x30</span>       <span class="p">(</span><span class="mi">480713</span> <span class="n">hits</span><span class="p">)</span>   <span class="p">(</span><span class="n">op</span><span class="o">=</span><span class="mh">0xd518203e</span><span class="o">/</span>  <span class="n">System</span> <span class="n">Reg</span><span class="p">)</span>
<span class="n">Instr</span><span class="p">:</span> <span class="n">msr</span> <span class="n">vbar_el1</span><span class="p">,</span> <span class="n">x30</span>        <span class="p">(</span><span class="mi">480671</span> <span class="n">hits</span><span class="p">)</span>   <span class="p">(</span><span class="n">op</span><span class="o">=</span><span class="mh">0xd518c01e</span><span class="o">/</span>  <span class="n">System</span> <span class="n">Reg</span><span class="p">)</span>
<span class="o">...</span>
</pre></div>
</div>
<p>To find the argument shorthand for the class you need to examine the
source code of the plugin at the moment, specifically the <cite>*opt</cite>
argument in the InsnClassExecCount tables.</p>
<ul class="simple">
<li><p>contrib/plugins/lockstep.c</p></li>
</ul>
<p>This is a debugging tool for developers who want to find out when and
where execution diverges after a subtle change to TCG code generation.
It is not an exact science and results are likely to be mixed once
asynchronous events are introduced. While the use of -icount can
introduce determinism to the execution flow it doesn’t always follow
the translation sequence will be exactly the same. Typically this is
caused by a timer firing to service the GUI causing a block to end
early. However in some cases it has proved to be useful in pointing
people at roughly where execution diverges. The only argument you need
for the plugin is a path for the socket the two instances will
communicate over:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">./</span><span class="n">sparc</span><span class="o">-</span><span class="n">softmmu</span><span class="o">/</span><span class="n">qemu</span><span class="o">-</span><span class="n">system</span><span class="o">-</span><span class="n">sparc</span> <span class="o">-</span><span class="n">monitor</span> <span class="n">none</span> <span class="o">-</span><span class="n">parallel</span> <span class="n">none</span> \
  <span class="o">-</span><span class="n">net</span> <span class="n">none</span> <span class="o">-</span><span class="n">M</span> <span class="n">SS</span><span class="o">-</span><span class="mi">20</span> <span class="o">-</span><span class="n">m</span> <span class="mi">256</span> <span class="o">-</span><span class="n">kernel</span> <span class="n">day11</span><span class="o">/</span><span class="n">zImage</span><span class="o">.</span><span class="n">elf</span> \
  <span class="o">-</span><span class="n">plugin</span> <span class="o">./</span><span class="n">contrib</span><span class="o">/</span><span class="n">plugins</span><span class="o">/</span><span class="n">liblockstep</span><span class="o">.</span><span class="n">so</span><span class="p">,</span><span class="n">arg</span><span class="o">=</span><span class="n">lockstep</span><span class="o">-</span><span class="n">sparc</span><span class="o">.</span><span class="n">sock</span> \
<span class="o">-</span><span class="n">d</span> <span class="n">plugin</span><span class="p">,</span><span class="n">nochain</span>
</pre></div>
</div>
<p>which will eventually report:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">qemu</span><span class="o">-</span><span class="n">system</span><span class="o">-</span><span class="n">sparc</span><span class="p">:</span> <span class="n">warning</span><span class="p">:</span> <span class="n">nic</span> <span class="n">lance</span><span class="o">.</span><span class="mi">0</span> <span class="n">has</span> <span class="n">no</span> <span class="n">peer</span>
<span class="o">@</span> <span class="mh">0x000000ffd06678</span> <span class="n">vs</span> <span class="mh">0x000000ffd001e0</span> <span class="p">(</span><span class="mi">2</span><span class="o">/</span><span class="mi">1</span> <span class="n">since</span> <span class="n">last</span><span class="p">)</span>
<span class="o">@</span> <span class="mh">0x000000ffd07d9c</span> <span class="n">vs</span> <span class="mh">0x000000ffd06678</span> <span class="p">(</span><span class="mi">3</span><span class="o">/</span><span class="mi">1</span> <span class="n">since</span> <span class="n">last</span><span class="p">)</span>
<span class="n">Δ</span> <span class="n">insn_count</span> <span class="o">@</span> <span class="mh">0x000000ffd07d9c</span> <span class="p">(</span><span class="mi">809900609</span><span class="p">)</span> <span class="n">vs</span> <span class="mh">0x000000ffd06678</span> <span class="p">(</span><span class="mi">809900612</span><span class="p">)</span>
  <span class="n">previously</span> <span class="o">@</span> <span class="mh">0x000000ffd06678</span><span class="o">/</span><span class="mi">10</span> <span class="p">(</span><span class="mi">809900609</span> <span class="n">insns</span><span class="p">)</span>
  <span class="n">previously</span> <span class="o">@</span> <span class="mh">0x000000ffd001e0</span><span class="o">/</span><span class="mi">4</span> <span class="p">(</span><span class="mi">809900599</span> <span class="n">insns</span><span class="p">)</span>
  <span class="n">previously</span> <span class="o">@</span> <span class="mh">0x000000ffd080ac</span><span class="o">/</span><span class="mi">2</span> <span class="p">(</span><span class="mi">809900595</span> <span class="n">insns</span><span class="p">)</span>
  <span class="n">previously</span> <span class="o">@</span> <span class="mh">0x000000ffd08098</span><span class="o">/</span><span class="mi">5</span> <span class="p">(</span><span class="mi">809900593</span> <span class="n">insns</span><span class="p">)</span>
  <span class="n">previously</span> <span class="o">@</span> <span class="mh">0x000000ffd080c0</span><span class="o">/</span><span class="mi">1</span> <span class="p">(</span><span class="mi">809900588</span> <span class="n">insns</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p>contrib/plugins/hwprofile</p></li>
</ul>
<p>The hwprofile tool can only be used with system emulation and allows
the user to see what hardware is accessed how often. It has a number of options:</p>
<blockquote>
<div><ul class="simple">
<li><p>arg=read or arg=write</p></li>
</ul>
<p>By default the plugin tracks both reads and writes. You can use one
of these options to limit the tracking to just one class of accesses.</p>
<ul class="simple">
<li><p>arg=source</p></li>
</ul>
<p>Will include a detailed break down of what the guest PC that made the
access was. Not compatible with arg=pattern. Example output:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cirrus</span><span class="o">-</span><span class="n">low</span><span class="o">-</span><span class="n">memory</span> <span class="o">@</span> <span class="mh">0xfffffd00000a0000</span>
 <span class="n">pc</span><span class="p">:</span><span class="n">fffffc0000005cdc</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">256</span>
 <span class="n">pc</span><span class="p">:</span><span class="n">fffffc0000005ce8</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">256</span>
 <span class="n">pc</span><span class="p">:</span><span class="n">fffffc0000005cec</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">256</span>
</pre></div>
</div>
<ul class="simple">
<li><p>arg=pattern</p></li>
</ul>
<p>Instead break down the accesses based on the offset into the HW
region. This can be useful for seeing the most used registers of a
device. Example output:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pci0</span><span class="o">-</span><span class="n">conf</span> <span class="o">@</span> <span class="mh">0xfffffd01fe000000</span>
  <span class="n">off</span><span class="p">:</span><span class="mi">00000004</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span>
  <span class="n">off</span><span class="p">:</span><span class="mi">00000010</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span>
  <span class="n">off</span><span class="p">:</span><span class="mi">00000014</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span>
  <span class="n">off</span><span class="p">:</span><span class="mi">00000018</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span>
  <span class="n">off</span><span class="p">:</span><span class="mi">0000001</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span>
  <span class="n">off</span><span class="p">:</span><span class="mi">00000020</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span>
  <span class="o">...</span>
</pre></div>
</div>
</div></blockquote>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">QEMU</a></h1>








<div id="editpage">
  <ul>
    <li><a href="https://gitlab.com/qemu-project/qemu/-/blob/master/docs/devel/tcg-plugins.rst">Page source</a></li>
  </ul>
</div><h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../system/index.html">System Emulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user/index.html">User Mode Emulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../interop/index.html">System Emulation Management and Interoperability</a></li>
<li class="toctree-l1"><a class="reference internal" href="../specs/index.html">System Emulation Guest Hardware Specifications</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Developer Information</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="code-of-conduct.html">Code of Conduct</a></li>
<li class="toctree-l2"><a class="reference internal" href="conflict-resolution.html">Conflict Resolution Policy</a></li>
<li class="toctree-l2"><a class="reference internal" href="build-system.html">The QEMU build system architecture</a></li>
<li class="toctree-l2"><a class="reference internal" href="style.html">QEMU Coding Style</a></li>
<li class="toctree-l2"><a class="reference internal" href="kconfig.html">QEMU and Kconfig</a></li>
<li class="toctree-l2"><a class="reference internal" href="testing.html">Testing in QEMU</a></li>
<li class="toctree-l2"><a class="reference internal" href="fuzzing.html">Fuzzing</a></li>
<li class="toctree-l2"><a class="reference internal" href="control-flow-integrity.html">Control-Flow Integrity (CFI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="loads-stores.html">Load and Store APIs</a></li>
<li class="toctree-l2"><a class="reference internal" href="memory.html">The memory API</a></li>
<li class="toctree-l2"><a class="reference internal" href="migration.html">Migration</a></li>
<li class="toctree-l2"><a class="reference internal" href="atomics.html">Atomic operations in QEMU</a></li>
<li class="toctree-l2"><a class="reference internal" href="stable-process.html">QEMU and the stable process</a></li>
<li class="toctree-l2"><a class="reference internal" href="qtest.html">QTest Device Emulation Testing Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="decodetree.html">Decodetree Specification</a></li>
<li class="toctree-l2"><a class="reference internal" href="secure-coding-practices.html">Secure Coding Practices</a></li>
<li class="toctree-l2"><a class="reference internal" href="tcg.html">Translator Internals</a></li>
<li class="toctree-l2"><a class="reference internal" href="tcg-icount.html">TCG Instruction Counting</a></li>
<li class="toctree-l2"><a class="reference internal" href="tracing.html">Tracing</a></li>
<li class="toctree-l2"><a class="reference internal" href="multi-thread-tcg.html">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="multi-thread-tcg.html#vcpu-scheduling">vCPU Scheduling</a></li>
<li class="toctree-l2"><a class="reference internal" href="multi-thread-tcg.html#shared-data-structures">Shared Data Structures</a></li>
<li class="toctree-l2"><a class="reference internal" href="multi-thread-tcg.html#memory-consistency">Memory Consistency</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">QEMU TCG Plugins</a></li>
<li class="toctree-l2"><a class="reference internal" href="bitops.html">Bitwise operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="reset.html">Reset in QEMU: the Resettable interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="s390-dasd-ipl.html">Booting from real channel-attached devices on s390x</a></li>
<li class="toctree-l2"><a class="reference internal" href="clocks.html">Modelling a clock tree in QEMU</a></li>
<li class="toctree-l2"><a class="reference internal" href="qom.html">The QEMU Object Model (QOM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="block-coroutine-wrapper.html">block-coroutine-wrapper</a></li>
<li class="toctree-l2"><a class="reference internal" href="multi-process.html">Multi-process QEMU</a></li>
</ul>
</li>
</ul>


<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2020, The QEMU Project Developers.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.4.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.8</a>
      
    </div>

    

    
  </body>
</html>