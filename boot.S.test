.section ".text.boot"
.global _start
.global _uart_flush
.global _uart_newline

_start:
    //Processor ID Check
    mrs     x1, mpidr_el1
    and     x1, x1, #3
    cbz     x1, 2f
    //Invalid Core - Infinite Loop
1:  wfe
    b       1b
2:  //Valid Core - Continue

    //Move Stack to After the End of _start
    ldr     x1, =_start
    mov     sp, x1

    //Clean the BSS Section
    ldr     x1, =__bss_start     //Start address
    ldr     w2, =__bss_size      //Section Size
3:  cbz     w2, 4f               //Quit Loop If Zero
    str     xzr, [x1], #8
    sub     w2, w2, #1
    cbnz    w2, 3b               //Loop If Non-Zero

    //[BEGIN_EXPERIMENTAL_SECTION]

4:  mov     x1, #0x0004		 //GPFSEL1
    movk    x1, #0xFE20, lsl #16
    movk    x1, #0x0000, lsl #32
    movk    x1, #0x0000, lsl #48
    ldr     w3, [x1]
    mov     w2, #0x0FFF
    movk    w2, #0xFFFC, lsl #16
    and     w3, w3, w2
    mov     w2, #0x2000		 //Pins 14 & 15 in ALT5
    movk    w2, #0x0001, lsl #16
    orr     w3, w3, w2
    str     w3, [x1]

    mov     x1, #0x00E4		 //GPIO_PUP_PDN_CNTRL_REG0
    movk    x1, #0xFE20, lsl #16
    movk    x1, #0x0000, lsl #32
    movk    x1, #0x0000, lsl #48
    mov     w2, #0xFFFF		 //Bits 28-31 in PULL_NONE
    movk    w2, #0x0FFF, lsl #16
    ldr     w3, [x1]
    and     w2, w3, w2
    str     w2, [x1]

    mov     x1, #0x5004		 //AUX_ENABLES
    movk    x1, #0xFE21, lsl #16
    movk    x1, #0x0000, lsl #32
    movk    x1, #0x0000, lsl #48
    mov     w2, #0x0001
    movk    w2, #0x0000, lsl #16
    str     w2, [x1]

    mov     x1, #0x5060		 //AUX_MU_CNTL_REG
    movk    x1, #0xFE21, lsl #16
    movk    x1, #0x0000, lsl #32
    movk    x1, #0x0000, lsl #48
    mov     w2, #0x0000
    movk    w2, #0x0000, lsl #16
    str     w2, [x1]

    mov     x1, #0x504C		 //AUX_MU_LCR_REG
    movk    x1, #0xFE21, lsl #16
    movk    x1, #0x0000, lsl #32
    movk    x1, #0x0000, lsl #48
    mov     w2, #0x0003		 //<--potentially read only
    movk    w2, #0x0000, lsl #16
    str     w2, [x1]

    mov     x1, #0x5048		 //AUX_MU_IIR_REG
    movk    x1, #0xFE21, lsl #16
    movk    x1, #0x0000, lsl #32
    movk    x1, #0x0000, lsl #48
    mov     w2, #0x00C6		 //<--potentially read only
    movk    w2, #0x0000, lsl #16
    str     w2, [x1]

    mov     x1, #0x5068		 //AUX_MU_BAUD_REG
    movk    x1, #0xFE21, lsl #16
    movk    x1, #0x0000, lsl #32
    movk    x1, #0x0000, lsl #48
    mov     w2, #0x021D		 //hex((500000000 / (115200 * 8)) - 1) //8x Oversampling
    movk    w2, #0x0000, lsl #16
    str     w2, [x1]

    mov     x1, #0x5060		 //AUX_MU_CNTL_REG
    movk    x1, #0xFE21, lsl #16
    movk    x1, #0x0000, lsl #32
    movk    x1, #0x0000, lsl #48
    mov     w2, #0x0003
    movk    w2, #0x0000, lsl #16
    str     w2, [x1]

    bl      _uart_flush
    bl      _uart_newline

    //[END_EXPERIMENTAL_SECTION]

    mov     w0, #0x41

5:  mov     x1, #0x5054		 //Wait for UART to be idle
    movk    x1, #0xFE21, lsl #16
    movk    x1, #0x0000, lsl #32
    movk    x1, #0x0000, lsl #48
    ldr     w2, [x1]
    and     w2, w2, #0x20
    cbz     w2, 5b

    mov     x1, #0x5040		 //Write 1 byte
    movk    x1, #0xFE21, lsl #16
    movk    x1, #0x0000, lsl #32
    movk    x1, #0x0000, lsl #48
    str     w0, [x1]

    mov     w0, #0x4D

6:  mov     x1, #0x5054		 //Wait for UART to be idle
    movk    x1, #0xFE21, lsl #16
    movk    x1, #0x0000, lsl #32
    movk    x1, #0x0000, lsl #48
    ldr     w2, [x1]
    and     w2, w2, #0x20
    cbz     w2, 6b

    mov     x1, #0x5040		 //Write 1 byte
    movk    x1, #0xFE21, lsl #16
    movk    x1, #0x0000, lsl #32
    movk    x1, #0x0000, lsl #48
    str     w0, [x1]

    //////////////

    mov     w0, #0x41

7:  mov     x1, #0x5054		 //Wait for UART to be idle
    movk    x1, #0xFE21, lsl #16
    movk    x1, #0x0000, lsl #32
    movk    x1, #0x0000, lsl #48
    ldr     w2, [x1]
    and     w2, w2, #0x20
    cbz     w2, 7b

    mov     x1, #0x5040		 //Write 1 byte
    movk    x1, #0xFE21, lsl #16
    movk    x1, #0x0000, lsl #32
    movk    x1, #0x0000, lsl #48
    str     w0, [x1]

    mov     w0, #0x4D

8:  mov     x1, #0x5054		 //Wait for UART to be idle
    movk    x1, #0xFE21, lsl #16
    movk    x1, #0x0000, lsl #32
    movk    x1, #0x0000, lsl #48
    ldr     w2, [x1]
    and     w2, w2, #0x20
    cbz     w2, 8b

    mov     x1, #0x5040		 //Write 1 byte
    movk    x1, #0xFE21, lsl #16
    movk    x1, #0x0000, lsl #32
    movk    x1, #0x0000, lsl #48
    str     w0, [x1]

    //Infinite Loop
    b       1b

_uart_flush:
    mov     w3, #0x05DC

1:  mov     w0, #0x00

2:  mov     x1, #0x5054	         //Wait for UART to be idle
    movk    x1, #0xFE21, lsl #16
    movk    x1, #0x0000, lsl #32
    movk    x1, #0x0000, lsl #48
    ldr     w2, [x1]
    and     w2, w2, #0x20
    cbz     w2, 2b

    mov     x1, #0x5040		 //Write 1 byte
    movk    x1, #0xFE21, lsl #16
    movk    x1, #0x0000, lsl #32
    movk    x1, #0x0000, lsl #48
    str     w0, [x1]

    sub     w3, w3, #1
    cbnz    w3, 1b
    ret

_uart_newline:
    mov     w0, #0x0D

1:  mov     x1, #0x5054	         //Wait for UART to be idle
    movk    x1, #0xFE21, lsl #16
    movk    x1, #0x0000, lsl #32
    movk    x1, #0x0000, lsl #48
    ldr     w2, [x1]
    and     w2, w2, #0x20
    cbz     w2, 1b

    mov     x1, #0x5040		 //Write 1 byte
    movk    x1, #0xFE21, lsl #16
    movk    x1, #0x0000, lsl #32
    movk    x1, #0x0000, lsl #48
    str     w0, [x1]

    mov     w0, #0x0A

2:  mov     x1, #0x5054	         //Wait for UART to be idle
    movk    x1, #0xFE21, lsl #16
    movk    x1, #0x0000, lsl #32
    movk    x1, #0x0000, lsl #48
    ldr     w2, [x1]
    and     w2, w2, #0x20
    cbz     w2, 2b

    mov     x1, #0x5040		 //Write 1 byte
    movk    x1, #0xFE21, lsl #16
    movk    x1, #0x0000, lsl #32
    movk    x1, #0x0000, lsl #48
    str     w0, [x1]

    ret