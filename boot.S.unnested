.section ".text.boot"
.global _start

.global _uart_setup
.global _uart_flush
.global _uart_newline
.global _uart_write_byte

.global _halt

_start:
	mrs	x1, mpidr_el1		//Processor ID Check
	and	x1, x1, #3
	cbz	x1, 1f
	bl	_halt			//Not Core 0 - Halt

1:	ldr	x1, =_start		//Core 0 - Continue Booting
	mov	sp, x1			//Move Stack to the end after all labels

	ldr	x1, =__bss_start	//Clean the BSS Section
	ldr	w2, =__bss_size
2:	cbz	w2, 3f			//Quit Loop If Zero
	str	xzr, [x1]
	add	x1, x1, #8              //#16
	sub	w2, w2, #1
	cbnz	w2, 2b			//Loop If Non-Zero

3:	bl	_uart_setup             //Hardware Initialisation
	bl	_uart_flush             //Nested Calls will not work automatically
	bl	_uart_newline

	mov	w0, #0x41		//Write ARM64 to the Serial Port
	bl	_uart_write_byte
	mov	w0, #0x52
	bl	_uart_write_byte
	mov	w0, #0x4D
	bl	_uart_write_byte
	mov	w0, #0x36
	bl	_uart_write_byte
	mov	w0, #0x34
	bl	_uart_write_byte
	bl	_uart_newline

	bl	_halt			//Bootloop until power down

_uart_setup:
	mov	x1, #0x0004		//GPFSEL1
	movk	x1, #0xFE20, lsl #16
	movk	x1, #0x0000, lsl #32
	movk	x1, #0x0000, lsl #48
	ldr	w3, [x1]
	mov	w2, #0x0FFF
	movk	w2, #0xFFFC, lsl #16
	and	w3, w3, w2
	mov	w2, #0x2000		//Pins 14 & 15 in ALT5
	movk	w2, #0x0001, lsl #16
	orr	w3, w3, w2
	str	w3, [x1]

	mov	x1, #0x00E4		//GPIO_PUP_PDN_CNTRL_REG0
	movk	x1, #0xFE20, lsl #16
	movk	x1, #0x0000, lsl #32
	movk	x1, #0x0000, lsl #48
	mov	w2, #0xFFFF		//Bits 28-31 in PULL_NONE
	movk	w2, #0x0FFF, lsl #16
	ldr	w3, [x1]
	and	w2, w3, w2
	str	w2, [x1]

	mov	x1, #0x5004		//AUX_ENABLES
	movk	x1, #0xFE21, lsl #16
	movk	x1, #0x0000, lsl #32
	movk	x1, #0x0000, lsl #48
	mov	w2, #0x0001
	movk	w2, #0x0000, lsl #16
	str	w2, [x1]

	mov	x1, #0x5060		//AUX_MU_CNTL_REG
	movk	x1, #0xFE21, lsl #16
	movk	x1, #0x0000, lsl #32
	movk	x1, #0x0000, lsl #48
	mov	w2, #0x0000
	movk	w2, #0x0000, lsl #16
	str	w2, [x1]

	mov	x1, #0x504C		//AUX_MU_LCR_REG
	movk	x1, #0xFE21, lsl #16
	movk	x1, #0x0000, lsl #32
	movk	x1, #0x0000, lsl #48
	mov	w2, #0x0003		//<--potentially read only
	movk	w2, #0x0000, lsl #16
	str	w2, [x1]

	mov	x1, #0x5048		//AUX_MU_IIR_REG
	movk	x1, #0xFE21, lsl #16
	movk	x1, #0x0000, lsl #32
	movk	x1, #0x0000, lsl #48
	mov	w2, #0x00C6		//<--potentially read only
	movk	w2, #0x0000, lsl #16
	str	w2, [x1]

	mov	x1, #0x5068		//AUX_MU_BAUD_REG
	movk	x1, #0xFE21, lsl #16
	movk	x1, #0x0000, lsl #32
	movk	x1, #0x0000, lsl #48
	mov	w2, #0x021D		//hex((500000000 / (115200 * 8)) - 1) //8x Oversampling
	movk	w2, #0x0000, lsl #16
	str	w2, [x1]

	mov	x1, #0x5060		//AUX_MU_CNTL_REG
	movk	x1, #0xFE21, lsl #16
	movk	x1, #0x0000, lsl #32
	movk	x1, #0x0000, lsl #48
	mov	w2, #0x0003
	movk	w2, #0x0000, lsl #16
	str	w2, [x1]

	ret
/*
_uart_flush:
	mov	w3, #0x05DC

1:	//mov	w0, #0x00
	//bl	_uart_write_byte

	sub	w3, w3, #1
	cbnz	w3, 1b
	ret
*/
_uart_flush:
    mov     w3, #0x05DC

1:  mov     w0, #0x00

2:  mov     x1, #0x5054	         //Wait for UART to be idle
    movk    x1, #0xFE21, lsl #16
    movk    x1, #0x0000, lsl #32
    movk    x1, #0x0000, lsl #48
    ldr     w2, [x1]
    and     w2, w2, #0x20
    cbz     w2, 2b

    mov     x1, #0x5040		 //Write 1 byte
    movk    x1, #0xFE21, lsl #16
    movk    x1, #0x0000, lsl #32
    movk    x1, #0x0000, lsl #48
    str     w0, [x1]

    sub     w3, w3, #1
    cbnz    w3, 1b
    ret

_uart_newline:
    mov     w0, #0x0D

1:  mov     x1, #0x5054	         //Wait for UART to be idle
    movk    x1, #0xFE21, lsl #16
    movk    x1, #0x0000, lsl #32
    movk    x1, #0x0000, lsl #48
    ldr     w2, [x1]
    and     w2, w2, #0x20
    cbz     w2, 1b

    mov     x1, #0x5040		 //Write 1 byte
    movk    x1, #0xFE21, lsl #16
    movk    x1, #0x0000, lsl #32
    movk    x1, #0x0000, lsl #48
    str     w0, [x1]

    mov     w0, #0x0A

2:  mov     x1, #0x5054	         //Wait for UART to be idle
    movk    x1, #0xFE21, lsl #16
    movk    x1, #0x0000, lsl #32
    movk    x1, #0x0000, lsl #48
    ldr     w2, [x1]
    and     w2, w2, #0x20
    cbz     w2, 2b

    mov     x1, #0x5040		 //Write 1 byte
    movk    x1, #0xFE21, lsl #16
    movk    x1, #0x0000, lsl #32
    movk    x1, #0x0000, lsl #48
    str     w0, [x1]

    ret

_uart_write_byte:
1:	mov	x1, #0x5054		//Wait for UART to be idle
	movk	x1, #0xFE21, lsl #16
	movk	x1, #0x0000, lsl #32
	movk	x1, #0x0000, lsl #48
	ldr	w2, [x1]
	and	w2, w2, #0x20
	cbz	w2, 1b

	mov	x1, #0x5040		//Write 1 byte
	movk	x1, #0xFE21, lsl #16
	movk	x1, #0x0000, lsl #32
	movk	x1, #0x0000, lsl #48
	str	w0, [x1]

	ret

_halt:
1:	wfe				//Infinite Event Loop
	b	1b
	ret